//@version=6
strategy("BTB_0.0 Strategy", overlay=true, max_labels_count=500, max_lines_count=500, max_boxes_count=1000,
     pyramiding=0, initial_capital=10000, currency=currency.USD, default_qty_type=strategy.percent_of_equity, default_qty_value=5, calc_on_every_tick=true)
//============================ TYPES & METHODS ============================
type pivotType
    float price
    int timestamp
    int index
    float barHigh
    float barLow

method copy(pivotType this, pivotType from) =>
    this.price := from.price
    this.timestamp := from.timestamp
    this.index := from.index
    this.barHigh := from.barHigh
    this.barLow := from.barLow
    this.barLow

method invalid(pivotType this) =>
    na(this.price)

method valid(pivotType this) =>
    not na(this.price)

method invalidate(pivotType this) =>
    this.price := na
    this.timestamp := na
    this.index := na
    this.barHigh := na
    this.barLow := na
    this.barLow

method set(pivotType this, float price, int timestamp, int index, float barHigh, float barLow) =>
    this.price := price
    this.timestamp := timestamp
    this.index := index
    this.barHigh := barHigh
    this.barLow := barLow
    this.barLow

method setHigher(pivotType this, pivotType pivot) =>
    if this.invalid() or pivot.price > this.price
        this.copy(pivot)

method setLower(pivotType this, pivotType pivot) =>
    if this.invalid() or pivot.price < this.price
        this.copy(pivot)

type pivotsType
    array<label> labels
    bool show
    color highColor
    color lowColor
    string style
    string size
    int maxCount

method add(pivotsType this, pivotType pivot, bool dir) =>
    if this.show and this.maxCount > 0
        labelText = switch this.style
            'text' => dir ? 'H' : 'L'
            => ''
        textColor = dir ? this.highColor : this.lowColor
        labelStyle = switch this.style
            'triangle' => dir ? label.style_triangleup : label.style_triangledown
            'dot' => label.style_circle
            => dir ? label.style_label_down : label.style_label_up
        labelColor = switch this.style
            'text' => color.new(color.black, 100)
            => dir ? this.highColor : this.lowColor
        labelLoc = switch this.style
            'triangle' => dir ? yloc.abovebar : yloc.belowbar
            => yloc.price
        lab = label.new(pivot.timestamp, pivot.price, labelText, xloc = xloc.bar_time, yloc = labelLoc, color = labelColor, style = labelStyle, textcolor = textColor, size = this.size, force_overlay = true)
        array.push(this.labels, lab)
        if array.size(this.labels) > this.maxCount
            lab := array.shift(this.labels)
            lab.delete()

method addHigh(pivotsType this, pivotType pivot) =>
    this.add(pivot, true)

method addLow(pivotsType this, pivotType pivot) =>
    this.add(pivot, false)

type trendType
    array<chart.point> points
    polyline line
    bool show
    color color
    string style
    int width

method add(trendType this, pivotType pivot) =>
    if this.show
        this.points.push(chart.point.from_time(pivot.timestamp, pivot.price))

method draw(trendType this) =>
    if this.show
        polyline.delete(this.line)
        style = switch this.style
            'solid' => line.style_solid
            'dotted' => line.style_dotted
            'dashed' => line.style_dashed
        this.line := polyline.new(this.points, xloc = xloc.bar_time, line_color = this.color, line_style = style, line_width = this.width, force_overlay = true)
        this.line

var pivots = pivotsType.new(array.new<label>())
var extTrend = trendType.new(array.new<chart.point>())
var intTrend = trendType.new(array.new<chart.point>())
var bool[] tzIsActive = array.new_bool()

//============================ INPUTS ============================
// Pivots Inputs
const string GRP_PIVOTS = 'Pivots'
pivots.show := input.bool(true, '', group = GRP_PIVOTS, inline = 'PIVOT_LABEL')
pivots.highColor := input.color(color.new(color.red, 50), 'High', group = GRP_PIVOTS, inline = 'PIVOT_LABEL')
pivots.lowColor := input.color(color.new(color.green, 50), 'Low', group = GRP_PIVOTS, inline = 'PIVOT_LABEL')
pivots.style := input.string('triangle', 'Style', ['text', 'triangle', 'dot'], group = GRP_PIVOTS, inline = 'PIVOT_LABEL')
pivots.size := input.string(size.auto, 'Size', [size.auto, size.tiny, size.small, size.normal, size.large, size.huge], group = GRP_PIVOTS, inline = 'PIVOT_LABEL')
pivots.maxCount := input.int(100, 'Maximum visible', minval = 0, maxval = 500, group = GRP_PIVOTS)

// Trend Inputs
const string GRP_TREND = 'Trend'
extTrend.show := input.bool(true, 'External', group = GRP_TREND, inline = 'TREND_EXT')
extTrend.color := input.color(color.rgb(255, 0, 0), '', group = GRP_TREND, inline = 'TREND_EXT')
extTrend.style := input.string('solid', 'Style', ['solid', 'dotted', 'dashed'], group = GRP_TREND, inline = 'TREND_EXT')
extTrend.width := input.int(1, 'Width', minval = 1, group = GRP_TREND, inline = 'TREND_EXT')
intTrend.show := input.bool(true, 'Internal', group = GRP_TREND, inline = 'TREND_INT')
intTrend.color := input.color(color.rgb(255, 0, 0), '', group = GRP_TREND, inline = 'TREND_INT')
intTrend.style := input.string('dashed', 'Style', ['solid', 'dotted', 'dashed'], group = GRP_TREND, inline = 'TREND_INT')
intTrend.width := input.int(1, 'Width', minval = 1, group = GRP_TREND, inline = 'TREND_INT')

// Zones Inputs
const string GRP_ZONES = 'Pivot Zones'
showZones = input.bool(true, 'Show pivot boxes', group = GRP_ZONES, inline = 'Z1')
zonesRight = input.int(1, 'Width (bars)', minval = 1, maxval = 50, group = GRP_ZONES, inline = 'Z1')
zoneHighBg = input.color(color.new(color.red, 80), 'High bg', group = GRP_ZONES, inline = 'Z2')
zoneLowBg = input.color(color.new(color.green, 80), 'Low bg', group = GRP_ZONES, inline = 'Z2')
maxZones = input.int(200, 'Maximum boxes', minval = 0, maxval = 500, group = GRP_ZONES)
showMergedLabel = input.bool(false, 'Show mergedSize label at 2nd pivot', group = GRP_ZONES)

// Bullish Pullback Zones Inputs
const string GRP_BULLISH_PULLBACK = 'Bullish Pullback Zones'
showBullishPullback = input.bool(true, 'Show Bullish Pullback Zones', group = GRP_BULLISH_PULLBACK)
detectBullishPullback = input.bool(true, 'Detect Bullish Pullback', group = GRP_BULLISH_PULLBACK)
bullishPullbackColor = input.color(color.new(color.blue, 80), 'Color', group = GRP_BULLISH_PULLBACK)
maxBullishPullbackZones = input.int(50, 'Maximum Zones', minval = 0, maxval = 500, group = GRP_BULLISH_PULLBACK)
bullishPullbackWidth = input.int(30, 'Width (bars)', minval = 1, maxval = 30, group = GRP_BULLISH_PULLBACK)

// Trend Detection Inputs
const string GRP_TREND_DETECTION = 'Trend Detection'
useEma300 = input.bool(true, 'Use EMA 300', group = GRP_TREND_DETECTION)
useEma100 = input.bool(true, 'Use EMA 100', group = GRP_TREND_DETECTION)
useEma50 = input.bool(true, 'Use EMA 50', group = GRP_TREND_DETECTION)
useEma20 = input.bool(true, 'Use EMA 20', group = GRP_TREND_DETECTION)
usePriceAction = input.bool(true, 'Use Price Action', group = GRP_TREND_DETECTION)
minBullishConfirmation = input.int(2, 'Min Bullish Confirmations', minval = 1, maxval = 4, group = GRP_TREND_DETECTION)

// FVG Inputs
const string GRP_FVG = 'FVG Settings'
showFvg = input.bool(true, 'Enable FVG Detection', group = GRP_FVG)
showFvgBoxes = input.bool(true, 'Show FVG Boxes', group = GRP_FVG)
showFvgLines = input.bool(true, 'Show FVG Lines', group = GRP_FVG)
fvgBoxLength = input.int(20, "Box Length", minval=5, group = GRP_FVG)
fvgMaxTrackBars = input.int(300, "Max Track Bars", group = GRP_FVG)
fvgCheckForwardBars = input.int(300, "Check Forward Bars", group = GRP_FVG)
fvgBullishColor = input.color(color.rgb(255, 251, 0), "Bullish FVG Color", group = GRP_FVG)
fvgBearishColor = input.color(color.red, "Bearish FVG Color", group = GRP_FVG)
// Display control for FVG lines vs Target Zones
fvgDisplayMode = input.string(title = 'FVG Display Mode',defval = 'In Target Zones',options = ['In Target Zones', 'Outside Target Zones', 'All'], group = GRP_FVG)

// Target Zones Inputs
const string GRP_TARGET = 'Target Zones'
showTargetZones = input.bool(true, 'Show Target Zones', group = GRP_TARGET)
showTargetZoneLines = input.bool(true, 'Show Target Zone Lines', group = GRP_TARGET)
targetMaxZones = input.int(50, 'Maximum boxes', minval = 0, maxval = 500, group = GRP_TARGET)
targetZoneColor = input.color(color.new(color.green, 70), 'Color', group = GRP_TARGET)

//============================ CORE LOGIC ============================
// --- Improved Trend Detection ---
ema300 = ta.ema(close, 300)
ema100 = ta.ema(close, 100)
ema50 = ta.ema(close, 50)
ema20 = ta.ema(close, 20)

bullishConditions = 0
bullishConditions := useEma300 and close > ema300 ? bullishConditions + 1 : bullishConditions
bullishConditions := useEma100 and close > ema100 ? bullishConditions + 1 : bullishConditions
bullishConditions := useEma50 and close > ema50 ? bullishConditions + 1 : bullishConditions
bullishConditions := useEma20 and close > ema20 ? bullishConditions + 1 : bullishConditions
bullishConditions := usePriceAction and close > open ? bullishConditions + 1 : bullishConditions

isBullish = bullishConditions >= minBullishConfirmation

find() =>
    var bool dir = true
    var pivotType h = pivotType.new(high, time, bar_index, high, low)
    var pivotType l = pivotType.new(low, time, bar_index, high, low)
    pivotType newh = pivotType.new()
    pivotType newl = pivotType.new()

    if dir
        if low < l.price
            if high > h.price
                h.set(high, time, bar_index, high, low)
            newh.copy(h)
            dir := false
            h.set(high, time, bar_index, high, low)
            l.set(low, time, bar_index, high, low)
        else if high > h.price
            l.set(low, time, bar_index, high, low)
            h.set(high, time, bar_index, high, low)
    else
        if high > h.price
            if low < l.price
                l.set(low, time, bar_index, high, low)
            newl.copy(l)
            dir := true
            h.set(high, time, bar_index, high, low)
            l.set(low, time, bar_index, high, low)
        else if low < l.price
            h.set(high, time, bar_index, high, low)
            l.set(low, time, bar_index, high, low)
    [newh, newl]

var bool trend = false
var pivotType eh = pivotType.new()
var pivotType el = pivotType.new()
var pivotType ih = pivotType.new()
var pivotType il = pivotType.new()

// --- Pullback zones (boxes) helpers/state ---
var array<box> pivotBoxes = array.new<box>()
var int lastPivotDir = na
var float lastPivotHigh = na
var float lastPivotLow = na
var float mergedSize = na

// --- Bullish Pullback Zones ---
var pivotType lastBullishHigh = pivotType.new()
var array<box> bullishPullbackBoxes = array.new<box>()

f_draw_pivot_box(pivotType pivot, bool isHigh) =>
    if showZones
        left = pivot.index
        right = pivot.index + zonesRight
        top = pivot.barHigh
        bottom = pivot.barLow
        colBg = isHigh ? zoneHighBg : zoneLowBg
        b = box.new(left, top, right, bottom, xloc = xloc.bar_index, bgcolor = colBg, border_color = color.new(colBg, 0))
        array.push(pivotBoxes, b)
        if array.size(pivotBoxes) > maxZones
            old = array.shift(pivotBoxes)
            box.delete(old)
        [pivot.barHigh, pivot.barLow]
    else
        [na, na]

// --- FVG Logic ---
var box[] fvgBoxes = array.new_box()
var label[] fvgLabels = array.new_label()
var int[] fvgCreatedBars = array.new_int()
var bool[] fvgIsBullish = array.new_bool()
var float[] fvgCompareLevels = array.new_float()
// Store all FVG tops/bottoms aligned with fvgBoxes
var float[] fvgTops = array.new_float()
var float[] fvgBottoms = array.new_float()
var bool[] fvgHasRetested = array.new_bool()

f_draw_fvg(int barIndex, float top, float bottom, string labelText, color fvgColor, float compare, bool isBullish, int len) =>
    realTop = math.max(top, bottom)
    realBot = math.min(top, bottom)
    mid = (realTop + realBot) / 2
    boxColor = color.new(fvgColor, 85)
    
    // Utiliser bar_index au lieu de time
    b = box.new(left=barIndex, right=barIndex + len, 
               top=realTop, bottom=realBot, border_color=color.rgb(255, 255, 255, 0), 
               bgcolor=boxColor, xloc=xloc.bar_index)  // <--- ici
    
    array.push(fvgBoxes, b)
    array.push(fvgCreatedBars, barIndex)
    array.push(fvgIsBullish, isBullish)
    array.push(fvgCompareLevels, compare)
    array.push(fvgTops, realTop)
    array.push(fvgBottoms, realBot)
    
    lbY = isBullish ? mid : mid - (realTop - realBot) * 0.3
    lb = label.new(x=barIndex, y=lbY, text=labelText, style=label.style_none, 
                  size=size.small, textcolor=isBullish ? color.rgb(123, 255, 0) : color.red, 
                  xloc=xloc.bar_index)  // <--- ici aussi
    
    array.push(fvgLabels, lb)
    array.push(fvgHasRetested, false)


// Cleanup FVG boxes and labels
if array.size(fvgBoxes) > 0
    for i = array.size(fvgBoxes) - 1 to 0
        isBullish = array.get(fvgIsBullish, i)
        compare = array.get(fvgCompareLevels, i)
        createdBar = array.get(fvgCreatedBars, i)
        age = bar_index - createdBar
        hasRetested = array.get(fvgHasRetested, i)

        if age > fvgMaxTrackBars
            box.delete(array.get(fvgBoxes, i))
            label.delete(array.get(fvgLabels, i))
            array.remove(fvgBoxes, i)
            array.remove(fvgLabels, i)
            array.remove(fvgCreatedBars, i)
            array.remove(fvgIsBullish, i)
            array.remove(fvgCompareLevels, i)
            array.remove(fvgTops, i)
            array.remove(fvgBottoms, i)
            array.remove(fvgHasRetested, i)
            continue

        if bar_index > createdBar and bar_index <= createdBar + fvgCheckForwardBars
            disrespect = (isBullish and close < compare) or (not isBullish and close > compare)
            // Handle first/second retest
            top = array.get(fvgTops, i)
            bot = array.get(fvgBottoms, i)
            fTop = math.max(top, bot)
            fBot = math.min(top, bot)
            retest = (low <= fTop and high >= fBot)
            if retest and not hasRetested
                array.set(fvgHasRetested, i, true)
            else if retest and hasRetested
                box.delete(array.get(fvgBoxes, i))
                label.delete(array.get(fvgLabels, i))
                array.remove(fvgBoxes, i)
                array.remove(fvgLabels, i)
                array.remove(fvgCreatedBars, i)
                array.remove(fvgIsBullish, i)
                array.remove(fvgCompareLevels, i)
                array.remove(fvgTops, i)
                array.remove(fvgBottoms, i)
                array.remove(fvgHasRetested, i)
                continue
            if disrespect
                box.delete(array.get(fvgBoxes, i))
                label.delete(array.get(fvgLabels, i))
                array.remove(fvgBoxes, i)
                array.remove(fvgLabels, i)
                array.remove(fvgCreatedBars, i)
                array.remove(fvgIsBullish, i)
                array.remove(fvgCompareLevels, i)
                array.remove(fvgTops, i)
                array.remove(fvgBottoms, i)
                array.remove(fvgHasRetested, i)

// Sync FVG boxes visibility with toggle
if array.size(fvgBoxes) > 0
    for i = 0 to array.size(fvgBoxes) - 1
        b = array.get(fvgBoxes, i)
        if not na(b)
            isBull = array.get(fvgIsBullish, i)
            baseCol = isBull ? fvgBullishColor : fvgBearishColor
            // 85 opacity when visible, near transparent when hidden
            newBg = showFvgBoxes ? color.new(baseCol, 85) : color.new(baseCol, 100)
            newBorder = showFvgBoxes ? color.new(baseCol, 0) : color.new(baseCol, 100)
            box.set_bgcolor(b, newBg)
            box.set_border_color(b, newBorder)

// Detect and draw FVG
if showFvg
    if low[1] > high[3] // Bullish FVG
        f_draw_fvg(bar_index[3], low[1], high[3], str.tostring(timeframe.period), fvgBullishColor, high[3], true, fvgBoxLength)
    
    if high[1] < low[3] // Bearish FVG
        f_draw_fvg(bar_index[3], low[3], high[1], str.tostring(timeframe.period), fvgBearishColor, low[3], false, fvgBoxLength)

//============================ TARGET ZONES ============================
// Fusion Bullish Pullback + FVG
var array<box> targetZones = array.new<box>()
// Store all Target Zone tops/bottoms aligned with targetZones
var float[] targetZoneTops = array.new_float()
var float[] targetZoneBottoms = array.new_float()
// Line arrays for drawing horizontal markers
var array<line> tzTopLines = array.new_line()
var array<line> tzBottomLines = array.new_line()
var array<line> fvgTopLines = array.new_line()
var array<line> fvgBottomLines = array.new_line()

f_check_and_draw_target_zone(box pullbackBox, box fvgBox) =>
    if showTargetZones and not na(pullbackBox) and not na(fvgBox)
        pbTop = box.get_top(pullbackBox)
        pbBot = box.get_bottom(pullbackBox)
        fvgTop = box.get_top(fvgBox)
        fvgBot = box.get_bottom(fvgBox)

        overlap = math.max(pbBot, fvgBot) <= math.min(pbTop, fvgTop)
        if overlap
            top = math.max(pbTop, fvgTop)
            bot = math.min(pbBot, fvgBot)
            // Use bar_index coordinates for left/right to avoid mixing xloc types
            pbLeft = box.get_left(pullbackBox)
            pbRight = box.get_right(pullbackBox)
            lastFvgCreatedBar = array.get(fvgCreatedBars, array.size(fvgCreatedBars) - 1)
            fvgLeftIdx = lastFvgCreatedBar
            fvgRightIdx = lastFvgCreatedBar + fvgBoxLength
            left = math.min(pbLeft, fvgLeftIdx)
            right = math.max(pbRight, fvgRightIdx)

            tz = box.new(left, top, right, bot,
                         xloc = xloc.bar_index,
                         bgcolor = targetZoneColor,
                         border_color = color.new(targetZoneColor, 0))
            array.push(targetZones, tz)
            array.push(targetZoneTops, top)
            array.push(targetZoneBottoms, bot)
            array.push(tzIsActive, true) 
            if array.size(targetZones) > targetMaxZones
                box.delete(array.shift(targetZones))
                array.shift(targetZoneTops)
                array.shift(targetZoneBottoms)
                // Also trim any excess drawn lines on drop; safe-guard in redraw step too
                if array.size(tzTopLines) > targetMaxZones
                    line.delete(array.shift(tzTopLines))
                if array.size(tzBottomLines) > targetMaxZones
                    line.delete(array.shift(tzBottomLines))

//============================ EXECUTION ============================
[h, l] = find()

if h.valid()
    pivots.addHigh(h)
    intTrend.add(h)
    [h_hi, h_lo] = f_draw_pivot_box(h, true)

    if isBullish
        lastBullishHigh.copy(h)

    if not na(lastPivotDir) and lastPivotDir == 0 and not na(h_hi) and not na(lastPivotLow)
        mergedSize := math.abs(h_hi - lastPivotLow)
        if showMergedLabel
            label.new(h.timestamp, h_hi, 'mergedSize: ' + str.tostring(mergedSize, format.mintick), xloc = xloc.bar_time, style = label.style_label_down, textcolor = color.white, color = color.new(color.gray, 0), size = size.tiny)

    if not na(h_hi) and not na(h_lo)
        lastPivotDir := 1
        lastPivotHigh := h_hi
        lastPivotLow := h_lo

    if el.invalid() and il.valid()
        el.copy(il)
        ih.copy(h)
        extTrend.add(el)

if l.valid()
    pivots.addLow(l)
    intTrend.add(l)
    [l_hi, l_lo] = f_draw_pivot_box(l, false)

    if detectBullishPullback and lastBullishHigh.valid() and isBullish
        highSize = lastBullishHigh.barHigh - lastBullishHigh.barLow
        lowSize = l.barHigh - l.barLow
        biggerSize = math.max(highSize, lowSize)

        left = lastBullishHigh.index
        right = left + bullishPullbackWidth
        bottom = lastBullishHigh.barHigh
        top = bottom + biggerSize

        pullbackBg = showBullishPullback ? bullishPullbackColor : color.new(bullishPullbackColor, 100)
        pullbackBorder = showBullishPullback ? color.new(bullishPullbackColor, 0) : color.new(bullishPullbackColor, 100)
        b = box.new(left, top, right, bottom, xloc = xloc.bar_index, bgcolor = pullbackBg, border_color = pullbackBorder)
        array.push(bullishPullbackBoxes, b)
        if array.size(bullishPullbackBoxes) > maxBullishPullbackZones
            box.delete(array.shift(bullishPullbackBoxes))

        lastBullishHigh.invalidate()

    if not na(lastPivotDir) and lastPivotDir == 1 and not na(l_lo) and not na(lastPivotHigh)
        mergedSize := math.abs(lastPivotHigh - l_lo)
        if showMergedLabel
            label.new(l.timestamp, l_lo, 'mergedSize: ' + str.tostring(mergedSize, format.mintick), xloc = xloc.bar_time, style = label.style_label_up, textcolor = color.white, color = color.new(color.gray, 0), size = size.tiny)

    if not na(l_hi) and not na(l_lo)
        lastPivotDir := 0
        lastPivotHigh := l_hi
        lastPivotLow := l_lo

    if eh.invalid() and ih.valid()
        eh.copy(ih)
        il.copy(l)
        extTrend.add(eh)

//============================ EXECUTION (TARGET ZONES) ============================
// Compare latest Bullish Pullback and latest FVG
if array.size(bullishPullbackBoxes) > 0 and array.size(fvgBoxes) > 0
    lastPB = array.get(bullishPullbackBoxes, array.size(bullishPullbackBoxes) - 1)
    lastFVG = array.get(fvgBoxes, array.size(fvgBoxes) - 1)
    f_check_and_draw_target_zone(lastPB, lastFVG)

if eh.valid() and high > eh.price
    if il.valid()
        el.copy(il)
        il.invalidate()
        extTrend.add(el)
    eh.invalidate()
    ih.invalidate()

if el.valid() and low < el.price
    if ih.valid()
        eh.copy(ih)
        ih.invalidate()
        extTrend.add(eh)
    el.invalidate()
    il.invalidate()

if h.valid()
    ih.setHigher(h)
if l.valid()
    il.setLower(l)

// Sync existing Bullish Pullback boxes style with visibility toggle
if array.size(bullishPullbackBoxes) > 0
    for i = 0 to array.size(bullishPullbackBoxes) - 1
        b = array.get(bullishPullbackBoxes, i)
        if not na(b)
            newBg = showBullishPullback ? bullishPullbackColor : color.new(bullishPullbackColor, 100)
            newBorder = showBullishPullback ? color.new(bullishPullbackColor, 0) : color.new(bullishPullbackColor, 100)
            box.set_bgcolor(b, newBg)
            box.set_border_color(b, newBorder)

if barstate.islast
    intTrend.draw()
    extTrend.draw()



// ================== EXEMPLE ==================
// Adapte en fonction de tes variables existantes
// Récupération et affichage de TOUTES les Target Zones et FVGs

// L'ancien affichage texte est supprimé; utilisation de lignes uniquement

// ================== AFFICHAGE ==================
// Supprime les labels de zone (remplacé par des lignes)
var label zoneLabel = na
if barstate.islast
    label.delete(zoneLabel)

// Dessine des lignes horizontales rouges au top/bottom de chaque Target Zone
// Respecte le toggle showTargetZoneLines
if showTargetZoneLines
    // Redimensionne/rafraichit à chaque barre
    tzCount = math.min(array.size(targetZones), math.min(array.size(targetZoneTops), array.size(targetZoneBottoms)))
    // Ensure arrays of lines have same size by deleting extras
    while array.size(tzTopLines) > tzCount
        line.delete(array.pop(tzTopLines))
    while array.size(tzBottomLines) > tzCount
        line.delete(array.pop(tzBottomLines))
    if tzCount > 0
        for i = 0 to tzCount - 1
            yTop = array.get(targetZoneTops, i)
            yBot = array.get(targetZoneBottoms, i)
            x1 = bar_index
            x2 = bar_index + 1
            // Create or update top line at price only, extend to the right
            if i >= array.size(tzTopLines)
                l = line.new(x1=x1, y1=yTop, x2=x2, y2=yTop, extend=extend.right, color=color.red, width=2)
                array.push(tzTopLines, l)
            else
                l = array.get(tzTopLines, i)
                line.set_xy1(l, x1, yTop)
                line.set_xy2(l, x2, yTop)
                line.set_extend(l, extend.right)
                line.set_color(l, color.red)
                line.set_width(l, 2)
            // Create or update bottom line at price only, extend to the right
            if i >= array.size(tzBottomLines)
                lb = line.new(x1=x1, y1=yBot, x2=x2, y2=yBot, extend=extend.right, color=color.red, width=2)
                array.push(tzBottomLines, lb)
            else
                lb = array.get(tzBottomLines, i)
                line.set_xy1(lb, x1, yBot)
                line.set_xy2(lb, x2, yBot)
                line.set_extend(lb, extend.right)
                line.set_color(lb, color.red)
                line.set_width(lb, 2)
else
    // Cleanup any existing lines when disabled
    while array.size(tzTopLines) > 0
        line.delete(array.pop(tzTopLines))
    while array.size(tzBottomLines) > 0
        line.delete(array.pop(tzBottomLines))

// Dessine des lignes horizontales jaunes au top/bottom de chaque FVG
// Respecte le toggle showFvgLines
if showFvgLines
    fvgCount = math.min(array.size(fvgBoxes), math.min(array.size(fvgTops), array.size(fvgBottoms)))
    // Determine which FVGs to display based on target zone overlap
    // Build a local array of booleans marking whether each FVG is inside any target zone
    var bool[] fvgInTarget = array.new_bool()
    // Ensure helper matches fvgCount length
    while array.size(fvgInTarget) > fvgCount
        array.pop(fvgInTarget)
    while array.size(fvgInTarget) < fvgCount
        array.push(fvgInTarget, false)
    // Compute overlap flags
    if fvgCount > 0 and array.size(targetZones) > 0
        tzN = math.min(array.size(targetZones), math.min(array.size(targetZoneTops), array.size(targetZoneBottoms)))
        for i = 0 to fvgCount - 1
            ft = array.get(fvgTops, i)
            fb = array.get(fvgBottoms, i)
            fTop = math.max(ft, fb)
            fBot = math.min(ft, fb)
            inside = false
            for j = 0 to tzN - 1
                tzTop = array.get(targetZoneTops, j)
                tzBot = array.get(targetZoneBottoms, j)
                tzTopNorm = math.max(tzTop, tzBot)
                tzBotNorm = math.min(tzTop, tzBot)
                // Overlap if FVG range intersects Target Zone range
                if math.max(fBot, tzBotNorm) <= math.min(fTop, tzTopNorm)
                    inside := true
                    break
            array.set(fvgInTarget, i, inside)
    while array.size(fvgTopLines) > fvgCount
        line.delete(array.pop(fvgTopLines))
    while array.size(fvgBottomLines) > fvgCount
        line.delete(array.pop(fvgBottomLines))
    if fvgCount > 0
        for i = 0 to fvgCount - 1
            showThis = switch fvgDisplayMode
                'In Target Zones' => array.get(fvgInTarget, i)
                'Outside Target Zones' => not array.get(fvgInTarget, i)
                => true // 'All'
            if not showThis
                // If we previously drew lines at this index, hide by making transparent
                if i < array.size(fvgTopLines)
                    tmp = array.get(fvgTopLines, i)
                    line.set_color(tmp, color.new(color.yellow, 100))
                if i < array.size(fvgBottomLines)
                    tmpb = array.get(fvgBottomLines, i)
                    line.set_color(tmpb, color.new(color.yellow, 100))
                continue

            fyTop = array.get(fvgTops, i)
            fyBot = array.get(fvgBottoms, i)
            x1 = bar_index
            x2 = bar_index + 1
            if i >= array.size(fvgTopLines)
                fl = line.new(x1=x1, y1=fyTop, x2=x2, y2=fyTop, extend=extend.right, color=color.yellow, width=1)
                array.push(fvgTopLines, fl)
            else
                fl = array.get(fvgTopLines, i)
                line.set_xy1(fl, x1, fyTop)
                line.set_xy2(fl, x2, fyTop)
                line.set_extend(fl, extend.right)
                line.set_color(fl, color.yellow)
                line.set_width(fl, 1)
            if i >= array.size(fvgBottomLines)
                flb = line.new(x1=x1, y1=fyBot, x2=x2, y2=fyBot, extend=extend.right, color=color.yellow, width=1)
                array.push(fvgBottomLines, flb)
            else
                flb = array.get(fvgBottomLines, i)
                line.set_xy1(flb, x1, fyBot)
                line.set_xy2(flb, x2, fyBot)
                line.set_extend(flb, extend.right)
                line.set_color(flb, color.yellow)
                line.set_width(flb, 1)
else
    // Cleanup any existing FVG lines when disabled
    while array.size(fvgTopLines) > 0
        line.delete(array.pop(fvgTopLines))
    while array.size(fvgBottomLines) > 0
        line.delete(array.pop(fvgBottomLines))

// ============================= EXTEND/FREEZE TARGET ZONES ON RETEST =============================
// Étendre automatiquement les Target Zones actives jusqu'au bar_index actuel,
// puis les figer dès qu'un retest touche le top ou le bottom
if array.size(targetZones) > 0 and array.size(targetZoneTops) == array.size(targetZones) and array.size(targetZoneBottoms) == array.size(targetZones)
    for i = 0 to array.size(targetZones) - 1
        // Ne traiter que les zones marquées actives
        if i < array.size(tzIsActive) and array.get(tzIsActive, i)
            tz = array.get(targetZones, i)
            tzTop = array.get(targetZoneTops, i)
            tzBot = array.get(targetZoneBottoms, i)

            // Étend la zone à la bougie courante
            box.set_right(tz, bar_index)

            // Gèle la zone si la bougie touche le top ou le bottom
            if (low <= tzTop and high >= tzTop) or (low <= tzBot and high >= tzBot)
                array.set(tzIsActive, i, false)

// ============================= BUY LABEL AU RETEST DU HAUT DE TARGETZONE =============================
strategy.risk.allow_entry_in(strategy.direction.long)

// Variables persistantes
var int hasRetested = 0
var int lastTZLeft  = na

// Tableau pour stocker les trades actifs (entry_time, entry_price, id)
var array<int>    entryTimes  = array.new_int()
var array<float>  entryPrices = array.new_float()
var array<string> orderIds    = array.new_string()

// Vérifie qu'il existe au moins une Target Zone
if array.size(targetZoneTops) > 0
    lastIdx = array.size(targetZones) - 1
    lastTZTop = array.get(targetZoneTops, array.size(targetZoneTops) - 1)
    lastTZBot = array.get(targetZoneBottoms, array.size(targetZoneBottoms) - 1)

    if lastIdx >= 0
        curLeft = box.get_left(array.get(targetZones, lastIdx))
        if na(lastTZLeft) or curLeft != lastTZLeft
            hasRetested := 0
            lastTZLeft := curLeft

    marketAboveTZ = close[1] > lastTZTop and close[2] > lastTZTop
    retestCondition = high >= lastTZTop and low <= lastTZTop

    if marketAboveTZ and retestCondition and hasRetested < 3
        orderId = "Buy_" + str.tostring(timenow) + "_" + str.tostring(hasRetested)

        // // Place order
        // strategy.entry(orderId, strategy.long)
        // takeProfit = close + 10.0
        // stopLoss   = close - 5.0
        // strategy.exit("Exit " + orderId, orderId, stop=stopLoss, limit=takeProfit)

        // Stocke les infos dans les arrays
        array.push(entryTimes,  timenow)
        array.push(entryPrices, close)
        array.push(orderIds,    orderId)

        // Label
        label.new(bar_index, lastTZTop, "RETEST TZ " + str.tostring(hasRetested+1),yloc=yloc.price, color=color.rgb(212, 0, 255), textcolor=color.white, style=label.style_label_up)

        // Vérifier le retest du FVG à l'intérieur de la Target Zone
        // Parcourir tous les FVGs actifs
        for fvgIdx = 0 to array.size(fvgBoxes) - 1
            fvgBox = array.get(fvgBoxes, fvgIdx)
            fvgTop = array.get(fvgTops, fvgIdx)
            fvgBot = array.get(fvgBottoms, fvgIdx)

            // Vérifier si ce FVG est à l'intérieur de la dernière Target Zone active
            // (On suppose que la dernière TZ est la plus pertinente pour le retest actuel)
            isFvgInLastTZ = (fvgTop <= lastTZTop and fvgBot >= lastTZBot) or (fvgBot <= lastTZTop and fvgTop >= lastTZBot)

            if isFvgInLastTZ
                // Condition de retest du FVG: le prix touche ou entre dans la zone du FVG
                retestFvgCondition = (low <= fvgTop and high >= fvgTop) or (low <= fvgBot and high >= fvgBot) or (low >= fvgBot and high <= fvgTop)

                if retestFvgCondition
                    label.new(bar_index, (fvgTop + fvgBot)/2, "RETEST FVG", yloc=yloc.price, color=color.rgb(0, 255, 255), textcolor=color.black, style=label.style_label_down)
                     // Place order
                    // strategy.entry(orderId, strategy.long)
                    // takeProfit = close + 10.0
                    // stopLoss   = close - 5.0
                    // strategy.exit("Exit ", stop=stopLoss, limit=takeProfit)
                    break // Placer un seul label par barre pour le retest FVG dans TZ




        hasRetested += 1







